#!/usr/bin/env python3
"""
IC1 F-I Curve Analysis Script

This script analyzes IC1 (current clamp step) protocols from patch-clamp recordings
and generates F-I (frequency-current) curves for multiple experimental conditions.

Features:
- Automatic IC1 protocol detection
- Voltage-clamp file exclusion
- Multi-part protocol filtering
- Spike detection using dV/dt threshold
- Cell-wise averaging with SEM error bars
- Exports publication-ready figures and CSV data

Author: Generated by patchAgent
Date: 2026-02-11
"""

import os
import sys
from pathlib import Path
import argparse
import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict
import csv

# Import patchAgent tools
try:
    import pyabf
    from patch_agent.tools.spike_tools import detect_spikes
except ImportError as e:
    print(f"Error: Required packages not found. {e}")
    print("Please install: pip install pyabf")
    print("And ensure patchAgent is installed: pip install -e .")
    sys.exit(1)


def find_ic1_files(base_dir, folder_to_condition):
    """
    Scan directory for IC1 current-clamp recordings.
    
    Parameters
    ----------
    base_dir : Path
        Base directory containing ABF files
    folder_to_condition : dict
        Mapping from folder names to condition names
    
    Returns
    -------
    ic1_files : dict
        Dictionary mapping condition names to lists of file paths
    excluded_vc : int
        Number of voltage-clamp files excluded
    """
    print("\n[STEP 1] Scanning for IC1 protocols...")
    abf_files = list(base_dir.glob("**/*.abf"))
    print(f"  Found {len(abf_files)} total ABF files")
    
    ic1_files = defaultdict(list)
    excluded_vc = 0
    excluded_multipart = 0
    
    for file_path in abf_files:
        try:
            abf = pyabf.ABF(str(file_path))
            
            # Determine condition from folder path
            condition = None
            for folder_name, cond_name in folder_to_condition.items():
                if folder_name in str(file_path):
                    condition = cond_name
                    break
            if condition is None:
                continue
            
            # Check protocol name for IC1
            protocol = abf.protocol if hasattr(abf, 'protocol') else ""
            is_ic1 = "IC1" in protocol.upper() or "IC 1" in protocol.upper() or "ICI" in protocol.upper()
            if not is_ic1:
                continue
            
            # Exclude voltage clamp recordings
            is_current_clamp = abf.adcUnits[0] == 'mV'
            if not is_current_clamp:
                excluded_vc += 1
                continue
            
            # Exclude multi-part protocols (IC1 should have simple step)
            if len(abf.sweepList) > 0:
                abf.setSweep(0)
                current = abf.sweepC
                unique_currents = np.unique(np.round(current, 1))
                is_simple = len(unique_currents) <= 3  # baseline + step + return
                
                if not is_simple:
                    excluded_multipart += 1
                    continue
            
            ic1_files[condition].append(str(file_path))
            
        except Exception as e:
            continue
    
    print(f"\n  IC1 Files Found:")
    for condition, files in sorted(ic1_files.items()):
        print(f"    {condition:20s}: {len(files):3d} files")
    print(f"\n  Excluded:")
    print(f"    Voltage clamp:     {excluded_vc}")
    print(f"    Multi-part:        {excluded_multipart}")
    
    return ic1_files, excluded_vc


def extract_fi_data(ic1_files):
    """
    Extract F-I curve data from IC1 files.
    
    Parameters
    ----------
    ic1_files : dict
        Dictionary mapping condition names to file paths
    
    Returns
    -------
    cell_data : dict
        Nested dict: condition -> cell_id -> current_amp -> [spike_counts]
    """
    print("\n[STEP 2] Extracting spike counts...")
    
    cell_data = {cond: defaultdict(lambda: defaultdict(list)) 
                 for cond in ic1_files.keys()}
    
    total_sweeps = 0
    
    for condition, files in ic1_files.items():
        for file_path in files:
            try:
                abf = pyabf.ABF(file_path)
                # Use parent folder as cell identifier
                cell_id = Path(file_path).parent.name
                
                for sweep_num in abf.sweepList:
                    abf.setSweep(sweep_num)
                    
                    t = abf.sweepX  # seconds
                    v = abf.sweepY  # mV
                    i = abf.sweepC  # pA
                    
                    # IMPROVED: Detect step boundaries first, then measure amplitude
                    # Find where current changes (step start and end)
                    di = np.abs(np.diff(i))
                    step_indices = np.where(di > 5)[0]  # 5 pA threshold
                    
                    if len(step_indices) >= 2:
                        step_start_idx = step_indices[0]
                        step_end_idx = step_indices[-1]
                        
                        # Measure baseline before step and during step
                        baseline_i = np.median(i[:step_start_idx]) if step_start_idx > 0 else i[0]
                        step_i = np.median(i[step_start_idx+10:step_end_idx]) if step_end_idx > step_start_idx+10 else np.median(i[step_start_idx:step_end_idx])
                        i_amp = round(step_i - baseline_i)
                        
                        t_start = t[step_start_idx]
                        t_end = t[step_end_idx]
                        
                        # Detect spikes
                        spikes = detect_spikes(v, t, dv_cutoff=20.0, min_peak=-30.0)
                        
                        # Count spikes during step
                        n_spikes = 0
                        if 'spike_times' in spikes and spikes['spike_times'] is not None:
                            spike_times = np.array(spikes['spike_times'])
                            n_spikes = np.sum((spike_times >= t_start) & (spike_times <= t_end))
                        
                        cell_data[condition][cell_id][i_amp].append(n_spikes)
                        total_sweeps += 1
            
            except Exception as e:
                continue
    
    print(f"  Processed {total_sweeps} sweeps")
    return cell_data


def compute_fi_curves(cell_data):
    """
    Compute F-I curves with mean and SEM across cells.
    
    Parameters
    ----------
    cell_data : dict
        Nested dict from extract_fi_data
    
    Returns
    -------
    fi_curves : dict
        condition -> current_amp -> {'mean', 'sem', 'n_cells'}
    """
    print("\n[STEP 3] Computing F-I curves...")
    
    fi_curves = {}
    
    for condition, cells in cell_data.items():
        # First average within each cell, then across cells
        currents_across_cells = defaultdict(list)
        
        for cell_id, cell_currents in cells.items():
            for i_amp, spike_list in cell_currents.items():
                # Average multiple trials for this cell at this current
                cell_avg = np.mean(spike_list)
                currents_across_cells[i_amp].append(cell_avg)
        
        # Compute mean and SEM across cells
        fi_curve = {}
        for i_amp, values in currents_across_cells.items():
            fi_curve[i_amp] = {
                'mean': np.mean(values),
                'sem': np.std(values) / np.sqrt(len(values)),
                'n_cells': len(values)
            }
        
        fi_curves[condition] = fi_curve
    
    # Print summary
    for condition, curve in fi_curves.items():
        n_cells = len(cell_data[condition])
        if curve:
            currents = sorted(curve.keys())
            print(f"  {condition}: {n_cells} cells, {min(currents)} to {max(currents)} pA")
    
    return fi_curves


def plot_fi_curves(fi_curves, output_dir):
    """
    Generate publication-ready F-I curve plot.
    
    Parameters
    ----------
    fi_curves : dict
        F-I curve data from compute_fi_curves
    output_dir : Path
        Directory to save figure
    """
    print("\n[STEP 4] Plotting...")
    
    fig, ax = plt.subplots(figsize=(11, 8))
    
    # Color scheme
    colors = {
        "Control": "#2E86AB",
        "+drug": "#A23B72",
        "+drug+antagonist": "#F18F01"
    }
    
    markers = {"Control": "o", "+drug": "s", "+drug+antagonist": "^"}
    
    for condition in sorted(fi_curves.keys()):
        if not fi_curves[condition]:
            continue
        
        currents = sorted(fi_curves[condition].keys())
        means = [fi_curves[condition][i]['mean'] for i in currents]
        sems = [fi_curves[condition][i]['sem'] for i in currents]
        n = fi_curves[condition][currents[0]]['n_cells']
        
        ax.errorbar(currents, means, yerr=sems,
                    label=f"{condition} (n={n})",
                    color=colors.get(condition, "#333333"),
                    marker=markers.get(condition, "o"),
                    markersize=10,
                    linewidth=2.5,
                    capsize=6,
                    capthick=2,
                    alpha=0.9)
    
    ax.set_xlabel("Current Injection (pA)", fontsize=16, fontweight='bold')
    ax.set_ylabel("Spike Count", fontsize=16, fontweight='bold')
    ax.set_title("F-I Curves: Drug Effects on Neuronal Excitability", 
                 fontsize=18, fontweight='bold', pad=20)
    ax.legend(fontsize=13, frameon=True, shadow=True, loc='upper left')
    ax.grid(True, alpha=0.25, linestyle='--')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.tick_params(labelsize=12)
    
    plt.tight_layout()
    
    output_path = output_dir / "FI_curves_IC1.png"
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    print(f"  Saved: {output_path}")
    
    return output_path


def save_data_csv(fi_curves, output_dir):
    """
    Save F-I curve data to CSV.
    
    Parameters
    ----------
    fi_curves : dict
        F-I curve data
    output_dir : Path
        Directory to save CSV
    """
    csv_path = output_dir / "FI_curves_data.csv"
    
    with open(csv_path, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["Condition", "Current_pA", "Mean_Spikes", "SEM", "N_Cells"])
        
        for condition in sorted(fi_curves.keys()):
            if not fi_curves[condition]:
                continue
            currents = sorted(fi_curves[condition].keys())
            for i_amp in currents:
                data = fi_curves[condition][i_amp]
                writer.writerow([condition, i_amp, data['mean'], data['sem'], data['n_cells']])
    
    print(f"  Saved: {csv_path}")
    return csv_path


def print_statistics(fi_curves, cell_data):
    """
    Print detailed statistics.
    
    Parameters
    ----------
    fi_curves : dict
        F-I curve data
    cell_data : dict
        Raw cell data
    """
    print("\n" + "=" * 70)
    print("STATISTICS")
    print("=" * 70)
    
    for condition in sorted(fi_curves.keys()):
        print(f"\n{condition.upper()}")
        print("-" * 70)
        
        if not fi_curves[condition]:
            print("  No data available")
            continue
        
        currents = sorted(fi_curves[condition].keys())
        n_cells = len(cell_data[condition])
        
        # Rheobase
        rheobase = None
        for i_amp in currents:
            if fi_curves[condition][i_amp]['mean'] >= 1.0:
                rheobase = i_amp
                break
        
        # Max firing
        max_firing = max([fi_curves[condition][i]['mean'] for i in currents])
        max_current = currents[-1]
        
        print(f"  Cells: {n_cells}")
        print(f"  Current range: {min(currents)} to {max(currents)} pA")
        print(f"  Rheobase: ~{rheobase} pA" if rheobase else "  Rheobase: Not determined")
        print(f"  Max firing: {max_firing:.2f} spikes at {max_current} pA")


def main():
    """Main analysis pipeline."""
    parser = argparse.ArgumentParser(
        description='Analyze IC1 protocols and generate F-I curves',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument('--input-dir', type=str, 
                        default=r'C:\Users\SMest\demo_dataset',
                        help='Directory containing ABF files (default: C:\\Users\\SMest\\demo_dataset)')
    
    parser.add_argument('--output-dir', type=str, 
                        default='./output',
                        help='Output directory for figures and data (default: ./output)')
    
    parser.add_argument('--conditions', type=str, nargs='+',
                        default=['control', '+conditon', '+condition+rescue'],
                        help='Folder names representing experimental conditions')
    
    parser.add_argument('--condition-names', type=str, nargs='+',
                        default=['Control', '+drug', '+drug+antagonist'],
                        help='Display names for conditions (must match --conditions order)')
    
    args = parser.parse_args()
    
    # Setup paths
    base_dir = Path(args.input_dir)
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    if not base_dir.exists():
        print(f"Error: Input directory not found: {base_dir}")
        sys.exit(1)
    
    # Map folder names to condition names
    if len(args.conditions) != len(args.condition_names):
        print("Error: --conditions and --condition-names must have same length")
        sys.exit(1)
    
    folder_to_condition = dict(zip(args.conditions, args.condition_names))
    
    print("=" * 70)
    print("IC1 F-I CURVE ANALYSIS")
    print("=" * 70)
    print(f"Input directory: {base_dir}")
    print(f"Output directory: {output_dir}")
    print(f"Conditions: {args.condition_names}")
    
    # Run analysis pipeline
    ic1_files, excluded_vc = find_ic1_files(base_dir, folder_to_condition)
    
    if not any(ic1_files.values()):
        print("\nError: No IC1 files found!")
        sys.exit(1)
    
    cell_data = extract_fi_data(ic1_files)
    fi_curves = compute_fi_curves(cell_data)
    
    # Generate outputs
    plot_fi_curves(fi_curves, output_dir)
    save_data_csv(fi_curves, output_dir)
    print_statistics(fi_curves, cell_data)
    
    print("\n" + "=" * 70)
    print("ANALYSIS COMPLETE")
    print("=" * 70)
    print(f"\nOutputs saved to: {output_dir.absolute()}")


if __name__ == "__main__":
    main()
